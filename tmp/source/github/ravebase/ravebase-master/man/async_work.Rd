% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{async_work}
\alias{async_work}
\title{Execute parallel job in another session}
\usage{
async_work(
  X,
  FUN,
  ...,
  .globals = NULL,
  .name = "Untitled",
  .rs = FALSE,
  .wait = TRUE,
  .chunk_size = Inf
)
}
\arguments{
\item{X}{vector}

\item{FUN}{R function}

\item{...}{further arguments to \code{FUN}}

\item{.globals}{named list of global variables to be used by \code{FUN}}

\item{.name}{job or progress name}

\item{.rs}{whether to use \code{'RStudio'} job scheduler}

\item{.wait}{whether to wait for the results}

\item{.chunk_size}{maximum chunk size per job, must be \code{Inf} if
\code{.wait} is false}
}
\value{
If \code{.wait} is true, then return list of results of \code{FUN}
being applied to each element of \code{X}, otherwise returns a function
that can be used to track and obtain the results.
}
\description{
Similar to \code{lapply} but run in parallel
}
\details{
Unlike \code{future} package functions, where the global variables
can be automatically determined, you must specify the variables to be used
by \code{FUN}. In addition, you may only assume base packages are loaded
when executing functions. Therefore it's recommended to call functions
with package names like \code{utils::read.csv} explicitly instead of
\code{read.csv} etc. See examples for details.

The main feature of \code{async_work} is that there is no backward
communication between main and slave process, hence the setup time is
faster than \code{future} \code{multiprocess}. There is no memory leak
issue caused by \code{forked} process, hence it's designed for process
that writes something to disk and doesn't require too much feed-backs.
However, using this function requires to specify \code{.globals}, which is
inconvenient for beginners.
}
\examples{

if(interactive()){
  a <- 1
  f <- function(x, b){
    Sys.sleep(1)
    list(
      result = x + a + b,
      loaded = names(utils::sessionInfo()$loaded),
      attached = search()
    )
  }

  # `a` is a "global" variable because `f` must need to look up for its
  # declaring environment, hence must be specified in `.globals`
  #
  res <- async_work(1:10, f, b = 3, .globals = list(a = a))

  # Only base libraries are attached
  res[[1]]
}

}
